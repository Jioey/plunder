#include <iostream>
#include <random>
#include <fstream>
#include <iomanip>

#include "../robot.h"

using namespace std;

int model = 0; // Default model

// ----- Helper Methods ---------------------------------------------

void setModel(int asp){
    model = asp;
}

double logistic(double midpoint, double steepness, double input){
    return 1.0 / (1.0 + exp(-steepness * (input - midpoint)));
}

/*
* Randomly transitions to an incorrect high-level action with specified probability
*/
HA putErrorIntoHA(int ha, Robot* r){
    int haDif = 0;
    if(!r->sampleDiscrete(r->haProbCorrect)){
        if(r->sampleDiscrete(0.5)) haDif = 1;
        else haDif = 2;
    }
    return static_cast<HA>((ha + haDif)%3);
}


// ----- Curated Selection of ASPs ---------------------------------------------

/*
* This is a hand-crafted action-selection policy.
*/
HA ASP_Hand(HA ha, Obs state, Robot* r){
    double xToTarget = r->target - state.pos;                                  // distance to the target

    bool cond1 = state.vel - r->vMax >= 0;                                     // is at max velocity (can no longer accelerate)
    bool cond2 = xToTarget - r->DistTraveled(state.vel, r->decMax) < epsilon;  // needs to decelerate or else it will pass target

    if(cond2){
        ha = DEC;
    }
    if(cond1 && !cond2){
        ha = CON;
    }
    if(!cond1 && !cond2){
        ha = ACC;
    }

    return ha;
}

/*
* This is a probabilistic hand-crafted action-selection policy.
*/
HA ASP_Hand_prob(HA ha, Obs state, Robot* r){
    double xToTarget = r->target - state.pos;                            // distance to the target
    // bool cond1 = vMax - state.vel < 0;                                // is at max velocity (can no longer accelerate)
    // bool cond2 = xToTarget - DistTraveled(state.vel, decMax) < 0;     // needs to decelerate or else it will pass target

    bool cond1smooth = r->sampleDiscrete(logistic(r->vMax*0.1, -50.0/r->vMax, r->vMax-state.vel));
    bool cond2smooth = r->sampleDiscrete(logistic(r->target*0.1, -50.0/r->target, xToTarget - r->DistTraveled(state.vel, r->decMax)));

    if(cond2smooth){
        ha = DEC;
    }
    if(cond1smooth && !cond2smooth){
        ha = CON;
    }
    if(!cond1smooth && !cond2smooth){
        ha = ACC;
    }
    
    return ha;
}

/*
* This is an action-selection policy generated by LDIPS, without error
*/
HA ASP_LDIPS(HA ha, Obs state, Robot* r){
    // Copy paste below
    if(ha == ACC && r->DistTraveled(state.vel, r->decMax) + state.pos - r->target >= -2.320007)
        ha = DEC;
    else if(ha == CON && r->DistTraveled(state.vel, r->decMax) - r->DistTraveled(r->vMax, r->decMax) >= -150.000000 && r->DistTraveled(r->vMax, r->decMax) + state.pos - r->target >= -0.095000)
        ha = DEC;
    else if(ha == ACC && state.vel - r->vMax >= -0.025000 && state.pos - r->target >= -499.975006)
        ha = CON;
    else if(ha == CON && r->vMax - state.vel >= 0.000000)
        ha = ACC;
    else if(ha == DEC && state.vel >= -1.000000)
        ha = DEC;
    else if(ha == ACC && state.pos >= -0.997500)
        ha = ACC;
    else if(ha == CON && state.vel >= 0.000000 && r->DistTraveled(r->vMax, r->decMax) - state.pos >= -128.399994)
        ha = CON;

    return ha;
}

/*
* This is an action-selection policy generated by LDIPS, with error
*/
HA ASP_LDIPS_error(HA ha, Obs state, Robot* r){
    // Copy paste below
    // if(ha == CON && DistTraveled(v, decMax) - DistTraveled(vMax, decMax) >= 9.714069)
    //     ha = CON;
    // else if(ha == DEC && DistTraveled(v, decMax) - target >= 11.458965)
    //     ha = CON;
    // else if(ha == CON && x + x + x - target >= 35.615170)
    //     ha = DEC;
    // else if(ha == ACC && DistTraveled(v, decMax) + target >= 535.545532)
    //     ha = CON;
    // else if(ha == CON)
    //     ha = ACC;
    // else if(ha == ACC && x - target + DistTraveled(v, decMax) >= -0.138184)
    //     ha = DEC;
    // else if(ha == DEC && DistTraveled(v, decMax) - x - x >= -49.242615)
    //     ha = ACC;
    // else if(ha == DEC)
    //     ha = DEC;
    // else if(ha == ACC)
    //     ha = ACC;

    // if(sampleDiscrete(0.33)){
    //     ha = ACC;
    // } else if (sampleDiscrete(0.5)){
    //     ha = DEC;
    // } else {
    //     ha = CON;
    // }

    if(state.pos < r->target / 2){
        ha = ACC;
    } else {
        ha = DEC;
    }

    return ha;
}

/*
* Transition robot high-level action based on current global state. Runs once per time step
*/
HA ASP_model(HA ha, Obs state, Robot* r){
    if(model == 0) {
        ha = ASP_Hand(ha, state, r);
    } else if(model == 1){
        ha = ASP_LDIPS(ha, state, r);
    } else if(model == 2){
        ha = ASP_LDIPS_error(ha, state, r);
    } else if(model == 3){
        ha = ASP_Hand_prob(ha, state, r);
    } else{
        cout << "Invalid model provided" << endl;
        exit(1);
    }

    return putErrorIntoHA(ha, r);
}