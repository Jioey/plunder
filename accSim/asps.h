#pragma once

#include <iostream>
#include <random>
#include <fstream>
#include <iomanip>

#include "../robot.h"

using namespace std;

typedef HA asp_t(HA, Obs, Robot*);

// ----- Helper Methods ---------------------------------------------

double logistic(double midpoint, double steepness, double input){
    return 1.0 / (1.0 + exp(-steepness * (input - midpoint)));
}

/*
* Randomly transitions to an incorrect high-level action with specified probability
*/
HA putErrorIntoHA(int ha, Robot* r){
    int haDif = 0;
    if(!r->sampleDiscrete(r->haProbCorrect)){
        if(r->sampleDiscrete(0.5)) haDif = 1;
        else haDif = 2;
    }
    return static_cast<HA>((ha + haDif)%3);
}


// ----- Curated Selection of ASPs ---------------------------------------------

/*
* This is a hand-crafted action-selection policy.
*/
HA ASP_Hand(HA ha, Obs state, Robot* r){
    double xToTarget = r->target - state.pos;                                  // distance to the target

    bool cond1 = state.vel - r->vMax >= 0;                                     // is at max velocity (can no longer accelerate)
    bool cond2 = xToTarget - r->DistTraveled(state.vel, r->decMax) < epsilon;  // needs to decelerate or else it will pass target

    if(cond2){
        ha = DEC;
    }
    if(cond1 && !cond2){
        ha = CON;
    }
    if(!cond1 && !cond2){
        ha = ACC;
    }

    return ha;
}

/*
* This is a probabilistic hand-crafted action-selection policy.
*/
HA ASP_Hand_prob(HA ha, Obs state, Robot* r){
    double xToTarget = r->target - state.pos;                            // distance to the target
    // bool cond1 = vMax - state.vel < 0;                                // is at max velocity (can no longer accelerate)
    // bool cond2 = xToTarget - DistTraveled(state.vel, decMax) < 0;     // needs to decelerate or else it will pass target

    bool cond1smooth = r->sampleDiscrete(logistic(r->vMax*0.1, -50.0/r->vMax, r->vMax-state.vel));
    bool cond2smooth = r->sampleDiscrete(logistic(r->target*0.1, -50.0/r->target, xToTarget - r->DistTraveled(state.vel, r->decMax)));

    if(cond2smooth){
        ha = DEC;
    }
    if(cond1smooth && !cond2smooth){
        ha = CON;
    }
    if(!cond1smooth && !cond2smooth){
        ha = ACC;
    }
    
    return ha;
}

/*
* This is an action-selection policy generated by LDIPS, without error
*/
HA ASP_LDIPS(HA ha, Obs state, Robot* r){
    // Copy paste below
    if(ha == ACC && r->DistTraveled(state.vel, r->decMax) + state.pos - r->target >= -2.320007)
        ha = DEC;
    else if(ha == CON && r->DistTraveled(state.vel, r->decMax) - r->DistTraveled(r->vMax, r->decMax) >= -150.000000 && r->DistTraveled(r->vMax, r->decMax) + state.pos - r->target >= -0.095000)
        ha = DEC;
    else if(ha == ACC && state.vel - r->vMax >= -0.025000 && state.pos - r->target >= -499.975006)
        ha = CON;
    else if(ha == CON && r->vMax - state.vel >= 0.000000)
        ha = ACC;
    else if(ha == DEC && state.vel >= -1.000000)
        ha = DEC;
    else if(ha == ACC && state.pos >= -0.997500)
        ha = ACC;
    else if(ha == CON && state.vel >= 0.000000 && r->DistTraveled(r->vMax, r->decMax) - state.pos >= -128.399994)
        ha = CON;

    return ha;
}

/*
* This is an action-selection policy generated by LDIPS, with error
*/
HA ASP_LDIPS_error(HA ha, Obs state, Robot* r){
    // Copy paste below
    // if(ha == CON && r->DistTraveled(state.vel, r->decMax) - r->DistTraveled(r->vMax, r->decMax) >= 9.714069)
    //     ha = CON;
    // else if(ha == DEC && r->DistTraveled(state.vel, r->decMax) - r->target >= 11.458965)
    //     ha = CON;
    // else if(ha == CON && state.pos + state.pos + state.pos - r->target >= 35.615170)
    //     ha = DEC;
    // else if(ha == ACC && r->DistTraveled(state.vel, r->decMax) + r->target >= 535.545532)
    //     ha = CON;
    // else if(ha == CON)
    //     ha = ACC;
    // else if(ha == ACC && state.pos - r->target + r->DistTraveled(state.vel, r->decMax) >= -0.138184)
    //     ha = DEC;
    // else if(ha == DEC && r->DistTraveled(state.vel, r->decMax) - state.pos - state.pos >= -49.242615)
    //     ha = ACC;
    // else if(ha == DEC)
    //     ha = DEC;
    // else if(ha == ACC)
    //     ha = ACC;

    if(r->sampleDiscrete(0.33)){
        ha = ACC;
    } else if (r->sampleDiscrete(0.5)){
        ha = DEC;
    } else {
        ha = CON;
    }

    return ha;
}

/*
* This is a simplistic action-selection policy with only ACC and DEC
*/
HA ASP_accDecOnly(HA ha, Obs state, Robot* r){
    if(state.pos < r->target / 2){
        ha = ACC;
    } else {
        ha = DEC;
    }
    return ha;
}


// ----- Main Functionality ---------------------------------------------

vector<asp_t*> ASPs;
int model = 0; // Default model
asp_t* curASP = ASP_Hand;

void init(){
    ASPs.push_back(ASP_Hand);
    ASPs.push_back(ASP_LDIPS);
    ASPs.push_back(ASP_LDIPS_error);
    ASPs.push_back(ASP_Hand_prob);
    ASPs.push_back(ASP_accDecOnly);
}

void setModel(int aspNum){
    if(ASPs.size() == 0){
        init();
    }
    
    if(aspNum >= ASPs.size()) {
        cout << "Invalid model provided" << endl;
        exit(1);
    }
    model = aspNum;
    curASP = ASPs[aspNum];
}

/*
* Selects one ASP to transition robot high-level action based on current global state. Runs once per time step
*/
HA ASP_model(HA ha, Obs state, Robot* r){
    ha = curASP(ha, state, r);
    return putErrorIntoHA(ha, r);
}